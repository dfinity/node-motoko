{"M0003":"# M0003\n\nThis error means that a module tried to import itself.\n\nErroneous code example (file is called `Self.mo`):\n\n```motoko\nimport S \"./Self\"; // import error, file Self.mo must not depend on itself\n\nmodule { ... }\n```\n\nIf you encounter this error you should probably remove the offending import.\n","M0137":"# M0137\n\nThis error means that you declared a type or class that explicitly or implicitly references\nan outer type parameter.\n\nErroneous code examples:\n\n```motoko\nclass C<T>(){\n  type U = T; // type U mentions parameter T of class C\n};\n```\n\n```motoko\nclass D<T>(){\n  class E(x : T) {\n    public let y : T = x; // class E mentions parameter T of class D in a field\n  };\n}\n```\n\nTo avoid this error, try parameterizing the inner types.\n\n```motoko\nclass C<T>(){\n  type U<T1> = T1;\n};\n```\n\n```motoko\nclass D<T>(){\n  class E<T1>(x : T1) {\n    public let y : T1 = x;\n  };\n}\n```\n\nThis is a temporary restriction of Motoko that we hope to remove in future.\n","M0149":"# M0149\n\nThis error means that you supplied an immutable record field (declared without `var`), where a mutable record field (specified with `var`), was expected.\n\nErroneous code example:\n\n```motoko\n{ count = 0 } : { var count : Nat }\n```\n\nIf you encounter this error, you should probably insert the `var` keyword:\n\n```motoko\n{ var count = 1 } : { var count : Nat }\n```\n","M0150":"# M0150\n\nThis error means you supplied a mutable record field (declared with `var`) where an immutable record field (specified without `var`) was expected.\n\nErroneous code example:\n\n```motoko\n{ var name = \"Fred\" } : { name : Text }\n```\n\nIf you encounter this error, you should probably omit `var`:\n\n```motoko\n{ name = \"Fred\" } : { name : Text }\n```\n","M0151":"# M0151\n\nThis error means that a object literal is missing some fields, maybe because of a typo.\n\nErroneous code examples:\n\n```motoko\n{ first_name = \"Fred\" } : { firstName : Text }\n{ firstName = \"Fred\" } : { firstName : Text; lastName : Text }\n```\n\nIf you encounter this error, you need to add the missing field name to the\nobject literal.\n\n```motoko\n{ firstName = \"Fred\" } : { firstName : Text }\n{ firstName = \"Fred\"; lastName = \"Flintstone\" } : { firstName : Text; lastName : Text }\n```\n","M0153":"# M0153\n\nThis error means that an imported Candid file (`.did`) mentions types that\ncannot be represented in Motoko. These are\n\n* `float32`\n* `service` types with method names that are not identifiers, e.g. because\n  they contain special characters.\n\nIf you encounter this error, and you can, you should avoid these types in the\nserviceâ€™s interface. If you have no control over the interface, you cannot\ninteract with it from Motoko.\n","M0154":"# M0154\n\nYou are using a field (typically a module field) that has a deprecation annotation\nattached to its definition, e.g.\n\n```motoko\nmodule SomeModule {\n\n  /// @deprecated The foo function is deprecated and will be removed next release\n  public func foo() {}\n\n}\n```\n\nThe warning should include an explanation provided by the author of that code.\n","M0155":"# M0155\n\nThis warning indicates that the type of a subtraction operation had to be deduced from its operands and was inferred to be `Nat`.\nThat implies that it traps when the result is negative, which may be unintentional.\n\nOffending code examples:\n\n```motoko\nfunc f(n : Nat) {\n  if (n < 10) { return };\n  let m = 2 * (n - 1);\n};\n\nfunc g(n : Nat) {\n  if (n - 1 < 10) { return };\n};\n```\n\nIf the subtraction was indeed intended to have a `Nat` result, you can let the compiler know by annotating the intended type explicitly:\n\n```motoko\nfunc f(n : Nat) {\n  let m : Nat = 2 * (n - 1);\n};\n```\n\nIf the intended type was `Int`, however, you can either annotate it as such:\n\n```\nfunc f(n : Nat) {\n  let m : Int = 2 * (n - 1);\n};\n```\n\nOr you can insert a sign operator `+`, which also forces the expression to be of type `Int`:\n\n```\nfunc f(n : Nat) {\n  let m = 2 * (+n - 1);\n};\n```\n\nThis latter possibility is particularly convenient in the case of comparisons, because it is always okay to perform them at type `Int`:\n\n```\nfunc g(n : Nat) {\n  if (+n - 1 < 10) { return };\n};\n```\n","M0156":"# M0156\n\nThis error means that a parameterized type definition, or set of type definitions, is too complicated for Motoko to accept.\n\nMotoko rejects type definitions that are expansive, in the sense that unfolding type definitions may produce an ever-expanding set of types.\n\nFor example, the type definition:\n\n```motoko\ntype List<T> = ?(T, List<T>);\n```\n\nthat recursively instantiates `List` at the same parameter `T`, is non-expansive and accepted, but the similar looking definition:\n\n```motoko\ntype Seq<T> = ?(T, Seq<[T]>);\n```\n\nthat recursively instantiates `Seq` with a larger type, `[T]`, containing `T`, is *expansive* and rejected.\n\nIf you encounter this error, try to restructure your type definitions to be non-expansive.\n","M0157":"# M0157\n\nThis error means that a type definition, or set of type definitions, is ill-defined.\n\nA type is _productive_ if recursively expanding any outermost type constructor in its definition\neventually produces a type other than the application of a type constructor.\n\nMotoko requires all type declarations to be productive.\n\nFor example, the type definitions:\n\n```motoko\ntype Person = { first : Text; last : Text };\n\ntype List<T> = ?(T, List<T>);\n\ntype Fst<T, U> = T;\n\ntype Ok<T> = Fst<Any, Ok<T>>;\n```\n\nare all productive and legal.\n\nBut the type definitions,\n\n```motoko\ntype C = C;\n\ntype D<T, U> = D<U, T>;\n\ntype E<T> = F<T>;\ntype F<T> = E<T>;\n\ntype G<T> = Fst<G<T>, Any>;\n```\n\nare all non-productive, since each definition will enter a loop after one or more\nexpansions of its body.\n\nIf you encounter this error, try to restructure your type definitions to be productive.\n","M0158":"# M0158\n\nThis error means that you declared a public class without providing it with a name.\n\nErroneous code example:\n\n```motoko\npublic class () {};\n```\n\nIf you encounter this error, you should probably name the class or make it private.\n\n```motoko\npublic class C() {};\n```\n\nPublic fields must be named since they determine the interface of the enclosing object.\n","M0194":"# M0194\n\nThis warning means that you defined an identifier without\nreferencing it later, a good indicator of dead code.\n\nDubious code example:\n\n```motoko\nlet nickname = \"klutz\";\n// code that never uses `nickname`\n```\n\nIf you encounter this warning, you can either delete the definition (if the code has no other side-effect),\n\n```motoko\n// code that never uses `nickname`\n```\n\nreplace it by a wildcard pattern:\n\n```motoko\nlet _ = \"klutz\";\n// code that never uses `nickname`\n```\n\nor just prefix the identifier with an underscore:\n\n```motoko\nlet _nickname = \"klutz\";\n// code that never uses `nickname`\n```\n","M0195":"# M0195\n\nThis warning means that you called a function that demands elevated (`system`) capabilities,\nwithout manifestly passing the capability.\n\n","M0197":"# M0197\n\nThis error means that you tried to call a function that requires (`system`) capabilities,\nin a context that does not provide them.\n\nOnly actor bodies, async expressions, non-query async function bodies and\nlocal functions with a leading `system` type parameter have system capabilities.\n\n","M0198":"# M0198\n\nThis warning means that you specified a field identifier in an object pattern without referencing this identifier later, a good indicator of dead code.\n\nDubious code example:\n\n```motoko\nimport Debug \"mo:base/Debug\";\n\nlet person = { firstName = \"Anna\"; secondName = \"Smith\" };\n\nlet { firstName; secondName } = person;\nDebug.print(firstName);\n\n// secondName is not used\n```\n\nIf you encounter this warning and the identifier is indeed not needed, \nyou can either remove the field identifier from the object pattern,\n\n```motoko\nimport Debug \"mo:base/Debug\";\n\nlet person = { firstName = \"Anna\"; secondName = \"Smith\" };\n\nlet { firstName } = person;\nDebug.print(firstName);\n```\n\nbind the field to a wildcard pattern:\n\n```motoko\nimport Debug \"mo:base/Debug\";\n\nlet person = { firstName = \"Anna\"; secondName = \"Smith\" };\n\nlet { firstName; secondName = _ } = person;\nDebug.print(firstName);\n\n// secondName is not needed\n```\n\nor bind the field to an identifier with an underscore prefix:\n\n```motoko\nimport Debug \"mo:base/Debug\";\n\nlet person = { firstName = \"Anna\"; secondName = \"Smith\" };\n\nlet { firstName; secondName = _secondName } = person;\nDebug.print(firstName);\n\n// secondName is not needed\n```\n"}